<html>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@2.3.0/dist/tf.min.js"></script> 

    
    <!-- <script src ="webcam.js"></script>
    <script src= "objectDetectorClient.js"></script>
     -->

    <body>
        <style>
            canvas { position: absolute; }
            #c1{ z-index: 1; }
            #c2{ z-index: 2; }
          </style>
          <a id = "link"></a>
          <div id="container">
                <label for="imgSrc">image Url:</label>
                <input type="text" id="imgSrc" value="http://localhost:8080/"><br>
                <button id="drawAndPredict">draw and predict</button>
                <canvas id="c1" width="416" height="416"></canvas>
                <canvas id="c2" width="416" height="416"></canvas>
                
          </div>
    </body>
    

<script>
    var gridSize = 13
    var anchors = tf.tensor([[0.044, 0.052], [0.144, 0.1585] , [0.257, 0.42] , [0.6, 0.27] , [0.751, 0.70]])
    var numAnchors = anchors.shape[0]
    
    var classList =[ 
        "black-bishop",
        "black-king",
        "black-knight",
        "black-pawn",
        "black-queen",
        "black-rook",
        "white-bishop",
        "white-king",
        "white-knight",
        "white-pawn",
        "white-queen",
        "white-rook"
    ]
    var numClasses = classList.length
    
    var dissectBatch = function(labelBatch){        
        labelBatch = labelBatch.reshape([-1,gridSize,gridSize, anchors.shape[0], 5 + numClasses])
        var x = labelBatch.slice([0,0, 0, 0, 0], [-1,-1, -1, -1, 1])
        var y = labelBatch.slice([0,0, 0, 0, 1], [-1,-1, -1, -1, 1])
        var w = labelBatch.slice([0,0, 0, 0, 2], [-1,-1,-1, -1, 1])
        var h = labelBatch.slice([0,0, 0, 0, 3], [-1,-1,-1,-1, 1])
        var objectness = labelBatch.slice([0,0, 0, 0, 4], [-1,-1,-1,-1, 1])
        var class_probabilities =  labelBatch.slice([0,0, 0, 0, 5], [-1,-1,-1,-1, numClasses])

        return [x, y, w, h, objectness, class_probabilities]
    }

    var extractValuesFromPredictedLabelBatch = function(labelBatch){
        var  [xBatch, yBatch, wBatch, hBatch, objectnessBatch, classProbabilitiesBatch] = dissectBatch(labelBatch)
        xBatch = xBatch.sigmoid()
        yBatch = yBatch.sigmoid()
        wBatch = wBatch.exp().mul(anchors.slice([0,0] , [5,1]))
        hBatch = hBatch.exp().mul(anchors.slice([0,1] , [5,1]))
        objectnessBatch = objectnessBatch.sigmoid()
        classProbabilitiesBatch = classProbabilitiesBatch.softmax().mul(objectnessBatch)

        return [xBatch, yBatch, wBatch, hBatch, objectnessBatch, classProbabilitiesBatch]        
    }

    var extractBoxesFromPredictedLabelBatch = (labelBatch, scoreThreshold) => {
        var batchSize = labelBatch.shape[0]
        var splitLabels = labelBatch.split(batchSize, 0)
       
        
        splitLabels = splitLabels.map( label => {
            var [x, y, w, h, objectness, class_probabilities] = extractValuesFromPredictedLabelBatch(label).map(tn => tn.reshape([gridSize*gridSize*numAnchors, tn.shape[tn.shape.length -1] ]))

            var halfWidth = w.div(tf.scalar(2))
            var halfHeight = h.div(tf.scalar(2))

            var boxes = tf.stack([x.sub(halfWidth), y.sub(halfHeight), x.add(halfWidth), y.add(halfHeight)]).transpose().squeeze()
            var classes = class_probabilities.argMax(-1, true);
            var scores = class_probabilities.max(-1, true).squeeze();

            var selected_indices = tf.image.nonMaxSuppression(boxes, scores, 10, 0.5,scoreThreshold)
            boxes = boxes.gather(selected_indices)
            scores = scores.gather(selected_indices)
            classes = classes.gather(selected_indices)

            return [classes,scores, boxes]
        
        })

        var splitClasses = splitLabels.map(label => label[0])
        var splitScores = splitLabels.map(label => label[1])
        var splitBoxes = splitLabels.map(label => label[2])

        return [
            splitClasses,
            splitScores,
            splitBoxes
        ]
    }

    async function loadImageFromSrc(imgSrc){
        var img = new Image();   // Create new img element
        promise =  new Promise(res => {
            img.addEventListener('load', async function() {
            res(img)                  
            })
        })
        img.src = imgSrc;
        img.crossOrigin = "anonymous"  
        return promise
    }
  
    function renderPrediction(prediction, canvas){
        var classes = prediction[0][0]
        var scores = prediction[1][0]
        var boxes = prediction[2][0]

        classes = classes.arraySync()
        scores = scores.arraySync()
        boxes = boxes.arraySync()

        ctx = canvas.getContext("2d")

        boxes.forEach((bb, i) => {
            if(scores[i] > 0.3){
                ctx.beginPath();
                ctx.rect(bb[0] * canvas.width, bb[1] * canvas.height, (bb[2] - bb[0]) * canvas.width, (bb[3] - bb[1]) * canvas.height)
                ctx.strokeStyle = "green"
                ctx.stroke()
                ctx.font = '10px serif';
                ctx.fillText(classList[classes[i]] + ": " + scores[i] , bb[0] * canvas.width - 1, bb[1] * canvas.height - 1);
            }
        })
    }
  (async ()=>{
    
    //detector = new objectDetectorClient(1)
    console.log("loading model")
    model = await tf.loadLayersModel("http://localhost:8080/model/model.json")
    console.log("model loaded")

    imgCanvas=document.getElementById("c1")
    bboxCanvas = document.getElementById("c2")

    imgCtx = imgCanvas.getContext("2d")
    bboxCtx = bboxCanvas.getContext("2d")

    var drawAndPredictBtn = document.getElementById("drawAndPredict")
    drawAndPredictBtn.onclick = async function(){
        console.log("fetching image")
        var imgSrc = document.getElementById("imgSrc").value
        var img = await loadImageFromSrc(imgSrc)
        imgCtx.drawImage(img,0,0, imgCanvas.width, imgCanvas.height)
        console.log("making prediction")
        var imgTensor = tf.browser.fromPixels(imgCanvas).expandDims()
        var prediction = await model.predict(imgTensor)

        prediction = extractBoxesFromPredictedLabelBatch(prediction) 
        console.log(prediction)
        bboxCtx.clearRect(0, 0, bboxCanvas.width, bboxCanvas.height)
        renderPrediction(prediction, bboxCanvas)

    }

    // render = async function(){
    //     ctx.clearRect(0, 0, canv.width, canv.height);
    //             if(bboxs){
    //                 bboxs.forEach((bb, i) => {
    //                         if(proba[i] > 0.3){
    //                             ctx.beginPath();
    //                             if(lbls[i] == 1){
    //                               ctx.strokeStyle = "#FF0000";
    //                             }
    //                             else{
    //                               ctx.strokeStyle = "#00FF00";
    //                             }
    //                             ctx.rect(bb[0] * canv.width, bb[1] * canv.height, (bb[2] - bb[0]) * canv.width, (bb[3] - bb[1]) * canv.height)
    //                             ctx.stroke()
    //                             ctx.font = '22px serif';
    //                             ctx.fillText(proba[i], 10, 50);
    //                        }
    //                       })
    //       }

    //     if(!predicting){
    //       predicting = true
    //       predicting = false            
    //                   detector.predict(imgData).then(outputs => {
    //                       predicting = false
    //                       imgData.dispose()
    //                       console.log(outputs)
    //                       //outputs.dispose()
    //                       bboxs = outputs[2]
    //                       proba = outputs[1]
    //                       lbls = outputs[0]
    //                   }) 
    //               }

    //     window.requestAnimationFrame(render)
    //}
    //render()

  })()

</script>
</html>